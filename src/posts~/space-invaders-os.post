title: Space Invaders OS
 desc: I write a simple OS whose only purpose is to play space invaders.
 date: 2023-02-26

Sectors are 512-byte increments every storage device—this could be a USB, hard
drive, or CD—is divided into. For example, I have a 500 GB hard drive which has
976562500 sectors because 500 GB is the same as 500,000,000,000 bytes, which
divided by 512 bytes is equal to 976562500 sectors.

When a computer powers on, the BIOS looks at the first sector of each storage device and if it ends with the magic number `0xaa55`, the BIOS knows this storage device is bootable and runs the machine code in the sector; thus this sector is called the boot sector or the master boot record (MBR). This is the way operating systems boot themselves.

An operating system is stored as an ISO image file, an uncompressed, sector-by-sector copy of a disc. To use an operating system on an ISO file you would copy this file byte-by-byte to a storage device of your choice, then plug this into a computer. This computer would recognize it as bootable because the first 512-bytes of the ISO file ends with the magic number `0xaa55`, which if you remember denotes a storage device as bootable.

An operating system's kernel is essential to its function, and its the job of the operating system's bootloader (stored in the first 512-bytes, so its ran by the BIOS) to load this kernel.

tried vblank, didn't work. see bookmarks

apparently gcc employs some sort of optimization to reduce the size of data by maybe pointing the same data to the same place. This would be fine i

originally I stored the images as an array of literal strings.

```c
char *octopus1[] = {
	"000011110000",
	"011111111110",
	"111111111111",
	"111001100111",
	"111111111111",
	"000110011000",
	"001101101100",
	"110000000011",
};
char *octopus2[] = {
	"000011110000",
	"011111111110",
	"111111111111",
	"111001100111",
	"111111111111",
	"001110011100",
	"011001100110",
	"001100001100",
};
```

This is completely fine until I had to adjust the images, like when I a bullet hits a block it must explode so I set zeros.

```c
char *block[] = {
	"00000011111111111111000000",
	"00000111111111111111100000",
	"00001111111111111111110000",
	"00011111111111111111111000",
	"00111111111111111111111100",
	"01111111111111111111111110",
	"11111111111111111111111111",
	"11111111111111111111111111",
	"11111111111111111111111111",
	"11111111111111111111111111",
	"11111111111111111111111111",
	"11111111111111111111111111",
	"11111111111111111111111111",
	"11111111111111111111111111",
	"11111111111111111111111111",
	"11111111111111111111111111",
	"11111111100000001111111111",
	"11111111000000000111111111",
	"11111110000000000011111111",
	"11111100000000000001111111",
	"11111100000000000001111111",
	"11111100000000000001111111",
};
```

But I forgot that string literals are meant to be *literals* and constant, so it's a no-brainer for compiler to point to exactly same string literals to the same memory location.

```c
int octopus1[] = {
	0,0,0,0,1,1,1,1,0,0,0,0,
	0,1,1,1,1,1,1,1,1,1,1,0,
	1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,0,0,1,1,0,0,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,
	0,0,0,1,1,0,0,1,1,0,0,0,
	0,0,1,1,0,1,1,0,1,1,0,0,
	1,1,0,0,0,0,0,0,0,0,1,1,
};
int octopus2[] = {
	0,0,0,0,1,1,1,1,0,0,0,0,
	0,1,1,1,1,1,1,1,1,1,1,0,
	1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,0,0,1,1,0,0,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,
	0,0,1,1,1,0,0,1,1,1,0,0,
	0,1,1,0,0,1,1,0,0,1,1,0,
	0,0,1,1,0,0,0,0,1,1,0,0,
};

int block[] = {
	0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
	0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
	0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,
	0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,
	0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,
	0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,
	1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,
	1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,
};
```

i spent a couple hours trying to figure out why I couldn't `call` functions in the bootloader. I narrowed it down to a problem with the stack. I noticed in the iso file, that the machine instructions were prefixed with `0x66`, so I suspected that the instructions were running in 32-bit or 64-bit mode instead of 16-bit mode. This was the case, and it turns out you need to put the `.code16` directive on top of your assembly to tell the `gas` assembler to output code for real mode. An excerpt from their documentation:

>>>
While GAS normally writes only "pure" 32-bit i386 code, it has limited support for writing code to run in real mode or in 16-bit protected mode code segments. To do this, insert a `.code16' directive before the assembly language instructions to be run in 16-bit mode. You can switch GAS back to writing normal 32-bit code with the `.code32' directive.
>>>

```bash
objcopy -I binary -O elf64-x86-64 cp866.psf cp866.o
```

Some technical notes:

- A single stage bootloader is all stored in a measly 512-bytes, but this is way
  to small for any proper, professional bootloader. (Just look at GRUB, it's a
  small operating system.)  There also exists two-stage bootloaders, which
  involves the first bootloader (loaded by the BIOS) loading a second bootloader
  which loads the kernel.
- I haven't loaded the A20 line because everything works fine without it. I
  think QEMU enables it by default.
